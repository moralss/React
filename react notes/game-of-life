import React from 'react'
import './index.css'
import { seedGrid, tick } from './game-of-life-board'

class Grid extends React.Component {
  constructor(props) {
    super(props)
    this.addedLiveCells = []
    this.arr = []
    this.defualVals = []
    this.state = {
      gridComponets: props.grid,
      set: [],
      board: props.grid,
      counter: 0,
      gens: [],
      element: "none",
      generations: [],
      starting: 0,
      startingGrid: [],
      grid: [],
      speed: 1000,
      defaults: [
        { status: 'alive', x: 2, y: 4 },
        { status: 'alive', x: 3, y: 4 },
        { status: 'alive', x: 4, y: 4 }
      ]
    }
    this.addCells = this.addCells.bind(this)
    this.reset = this.reset.bind(this)
    this.start = this.start.bind(this)
    this.increaseSpeed = this.increaseSpeed.bind(this)
    this.GenerateRandomliveCells = this.GenerateRandomliveCells.bind(this)
    this.pause = this.pause.bind(this)
    this.set = this.set.bind(this)
    this.decreaseSpeed = this.decreaseSpeed.bind(this)
  }

  addCells(e) {
    if (e.status === 'dead') {
      e.status = 'alive'
      this.arr.push({ x: e.x, y: e.y, status: 'alive' })
    } else {
      e.status = 'dead'
      this.arr.splice(this.arr.indexOf(e), 1, {
        x: e.x,
        y: e.y,
        status: 'dead'
      })
    }
    this.setState({ defaults: this.arr })
    this.setState({ startingGrid: this.arr })
  }
  increaseSpeed() {
    this.setState({ speed: this.state.speed - 500 })
    console.log(this.state.speed)
  }
  decreaseSpeed() {
    this.setState({ speed: this.state.speed + 1000 })
    console.log(this.state.speed)
  }
  reset() {
    this.defualVals = []
    var arr = []
    for (var i = 0; i < 20; i++) {
      for (var j = 0; j < 20; j++) {
        this.defualVals.push({ status: 'dead', x: i, y: j })
      }
    }
    this.setState({ gridComponets: this.defualVals })
  }
  componentDidMount() {
    this.GenerateRandomliveCells()

  }
  pause() {
    this.setState({ starting: 1 })
    this.setState({ element: "none" })
  }
  stop() {
    this.setState({ set: [] })
    this.reset();
    this.setState({ counter: 0 })
    this.setState({ element: "none" })
    this.arr = [];
    this.setState({ defaults: [], starting: 1, gridComponets: this.defualVals })
    // var alive = this.state.generations.find(x => x.status = "alive");
    // console.log(alive)
  }

  GenerateRandomliveCells() {
    var arr = []
    var deadCells = this.props.grid;
    for (var i = 2; i < 20; i++) {
      for (var j = 1; j < 20; j++) {
        var rand = Math.random()
        var pushe = { status: 'alive', x: Math.floor(rand * i + 1), y: Math.floor(rand * j + 2) };
        var found = arr.find(x => x.x === pushe.x && x.y === pushe.y)
        if (found === undefined) {
          arr.push(pushe)
        }
        for (var cell of arr) {
          var found = deadCells.find(x => x.x === cell.x && x.y === cell.y)
          if (found !== undefined) {
            var index = deadCells.indexOf(found)
            deadCells.splice(index, 1, cell)
            this.setState({ gridComponets: deadCells })
          }
        }

      }
    }
    this.setState({ startingGrid: arr })
    console.log(arr)
  }

  start() {
    this.reset()
    console.log("should start")
    this.setState({ startingGrid: this.state.defaults })
    //    var startingGrid = this.state.defaults
    seedGrid(this.state.startingGrid)
    this.setState({ element: "element" })
    this.set()

  }
  set() {
    this.setState({ starting: 0 })
    var setInt = setInterval(() => { starting() }, this.state.speed);
    var starting = () => {
      this.setState({ counter: this.state.counter + 1 })
      var board = tick()

      var deadCells = this.defualVals.slice()
      var arr = []
      for (var cell of board) {
        var found = deadCells.find(x => x.x === cell.x && x.y === cell.y)
        if (found !== undefined) {
          var index = deadCells.indexOf(found)
          deadCells.splice(index, 1, cell)
          this.setState({ gridComponets: deadCells, generations: deadCells })
        }
      }
      var stopInt = () => {
        clearInterval(setInt)
      }
      if (this.state.starting !== 0) {
        stopInt();
        console.log("should stop")
      }

    }
  }
  render() {
    return (
      <div>
        <div className="buttons">
          <h1> {"Game of life"} </h1>
          <button onClick={() => this.start()}>
            start
          </button>
          <button onClick={() => this.increaseSpeed()}>
            +
          </button>
          <button onClick={() => this.decreaseSpeed()}>
            -
          </button>
          <button onClick={() => this.GenerateRandomliveCells()}>
            + Random cells
          </button>
          <button onClick={() => this.pause()}>
            pause
          </button>
          <button onClick={() => this.stop()}>
            clear
          </button>
          <h2>{this.state.counter}</h2>
        </div>
        <div className={this.state.element}>
          <div className='grid-container'>
            {this.state.gridComponets.map(x => (
              <button key={this.state.gridComponets.indexOf(x)} onClick={e =>
               this.addCells(x)} className={x.status === 'alive' ? 'cell alive' : 'cell dead'} ></button>
            ))}
          </div>
        </div>
      </div >
    )
  }
}

export default Grid



var firstGenerationGrid;
var newGen = [];
var startingGrid = [
  { x: 1, y: 1, status: "alive" },
  { x: 1, y: 2, status: "alive" },
  { x: 2, y: 1, status: "alive" },
  { x: 3, y: 4, status: "alive" },
  { x: 4, y: 3, status: "alive" },
  { x: 4, y: 4, status: "alive" }
];
var currentBoard = [];
// { x: 1, y: 1, status: "alive" },
//   { x: 1, y: 2, status: "alive" },
//   { x: 2, y: 1, status: "alive" },
//   { x: 3, y: 4, status: "alive" },
//   { x: 4, y: 3, status: "alive" },
//   { x: 4, y: 4, status: "alive" }
function checkLivesNeighbors(firstGenerationGrid, x, y) {
  var liveNeighborCellCount = 0;
  var cellPositions = startingGrid;
  var thevalueOfX = x;
  var thevalueOfY = y;

  // var initial = cellPositions.find(c => {
  //   return c.x === x && c.y === y ;
  // });

  var rightNeighbor = cellPositions.find(c => {
    return c.x === x && c.y === y + 1;
  });

  var leftNeighbor = cellPositions.find(c => {
    return c.x === x && c.y === y - 1;
  });
  // var leftNeighbor = cellPositions.find(c => {
  //   return c.x === x - 1 && c.y === y - 1;
  // });
  var topRight = cellPositions.find(c => {
    return c.x === x - 1 && c.y === y + 1;
  });
  var topLeft = cellPositions.find(c => {
    return c.x === x - 1 && c.y === y - 1;
  });
  var bottomLeft = cellPositions.find(c => {
    return c.x === x + 1 && c.y === y - 1;
  });
  var bottomRight = cellPositions.find(c => {
    return c.x === x + 1 && c.y === y + 1;
  });
  var top = cellPositions.find(c => {
    return c.x === x - 1 && c.y === y;
  });
  var bottom = cellPositions.find(c => {
    return c.x === x + 1 && c.y === y;
  });

  if (bottom !== undefined) {
    liveNeighborCellCount += 1;
  }

  if (top !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (bottomLeft !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (bottomRight !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (leftNeighbor !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (rightNeighbor !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (topLeft !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (topRight !== undefined) {
    liveNeighborCellCount += 1;
  }
  var position = cellPositions.find(p => p.x === x && p.y === y);
  if (
    position !== undefined &&
    (liveNeighborCellCount === 2 || liveNeighborCellCount === 3)
  ) {
    newGen.push(position);
  }
  else if (position === undefined && liveNeighborCellCount === 3) {
    newGen.push({ x: x, y: y, status: "alive" });
  }
  return newGen;
}
function initialIndex() {
  var generation = startingGrid;

  var highestX = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.x;
    return Math.max(acc, val);
  }, 0);

  var lowestX = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.x;
    return Math.min(acc, val);
  }, 10000000000000);

  var highestY = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.y;
    return Math.max(acc, val);
  }, 0);

  var lowestY = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.y;
    return Math.min(acc, val);
  }, 1000000000000);

  for (var x = lowestX - 1; x < highestX + 1; x++) {
    for (var y = lowestY - 1; y < highestY + 1; y++) {
      checkLivesNeighbors(firstGenerationGrid, x, y);
    }
  }
  startingGrid = [];
  startingGrid = newGen;
  console.log(newGen);
  newGen = [];
  return checkLivesNeighbors();
}
var timeLoop = x => {
  setInterval(() => initialIndex(), 4000);
};

initialIndex();


var firstGenerationGrid;
var newGen = [];
var startingGrid = [];
var currentBoard = [];

function checkLivesNeighbors(firstGenerationGrid, x, y) {
  var liveNeighborCellCount = 0;
  var cellPositions = startingGrid;

  var rightNeighbor = cellPositions.find(c => {
    return c.x === x && c.y === y + 1;
  });

  var leftNeighbor = cellPositions.find(c => {
    return c.x === x && c.y === y - 1;
  });
  var topRight = cellPositions.find(c => {
    return c.x === x - 1 && c.y === y + 1;
  });
  var topLeft = cellPositions.find(c => {
    return c.x === x - 1 && c.y === y - 1;
  });
  var bottomLeft = cellPositions.find(c => {
    return c.x === x + 1 && c.y === y - 1;
  });
  var bottomRight = cellPositions.find(c => {
    return c.x === x + 1 && c.y === y + 1;
  });
  var top = cellPositions.find(c => {
    return c.x === x - 1 && c.y === y;
  });
  var bottom = cellPositions.find(c => {
    return c.x === x + 1 && c.y === y;
  });

  if (bottom !== undefined) {
    liveNeighborCellCount += 1;
  }

  if (top !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (bottomLeft !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (bottomRight !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (leftNeighbor !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (rightNeighbor !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (topLeft !== undefined) {
    liveNeighborCellCount += 1;
  }
  if (topRight !== undefined) {
    liveNeighborCellCount += 1;
  }
  var position = cellPositions.find(p => p.x === x && p.y === y);
  if (
    position !== undefined &&
    (liveNeighborCellCount === 2 || liveNeighborCellCount === 3)
  ) {
    newGen.push(position);
  } else if (position === undefined && liveNeighborCellCount === 3) {
    newGen.push({ x: x, y: y, status: "alive" });
  }
  return startingGrid;
}

function seedGrid(grid) {
  startingGrid = grid;
}

function tick() {
  var generation = startingGrid;

  var highestX = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.x;
    return Math.max(acc, val);
  }, 0);

  var lowestX = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.x;
    return Math.min(acc, val);
  }, 10000000000000);

  var highestY = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.y;
    return Math.max(acc, val);
  }, 0);

  var lowestY = generation.reduce((acc, val) => {
    var acc = acc;
    var val = val.y;
    return Math.min(acc, val);
  }, 1000000000000);

  for (var x = lowestX - 1; x < highestX + 2; x++) {
    for (var y = lowestY - 1; y < highestY + 2; y++) {
      checkLivesNeighbors(firstGenerationGrid, x, y);
    }
  }
  startingGrid = [];
  startingGrid = newGen;
  newGen = [];
  return startingGrid;
}

module.exports = { checkLivesNeighbors, tick, startingGrid, seedGrid };

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

function generateNextGeneration(currentGeneration) {
    var grid = [];
    var newGeneration = [];
    if (currentGeneration === undefined) {
        currentGeneration = [];
        for (let secondIndex = 5; secondIndex < 19; secondIndex++) {
            for (let index = 5; index < 19; index++) {
                let newItem = { xAxis: Math.floor(Math.random() * 19), yAxis: Math.floor(Math.random() * 19), status: true };
                if (currentGeneration.indexOf(newItem) === -1) {
                    currentGeneration.push(newItem);
                }
            }
        }
    }
    var lowestAndHighest = getLowestAndHighest(currentGeneration)
    for (let xAxisCounter = lowestAndHighest.lowestX - 2; xAxisCounter <= lowestAndHighest.highestX + 2; xAxisCounter++) {
        for (let yAxisCounter = lowestAndHighest.lowestY - 2; yAxisCounter <= lowestAndHighest.highestY + 2; yAxisCounter++) {
            grid.push({ xAxis: xAxisCounter, yAxis: yAxisCounter, status: false })
        }
    }
    currentGeneration.forEach(currentItem => {
        var ItemFound = grid.find(item => item.xAxis === currentItem.xAxis && item.yAxis === currentItem.yAxis);
        var position = grid.indexOf(ItemFound);
        grid[position].status = true
    });
    grid.forEach(currentItem => {
        var aliveNeighbors = [];
        var currentItemsNeighbors = getAllNeighbors(currentItem);
        currentItemsNeighbors.forEach(singleNeighbor => {
            var neighborMatch = grid.find(element => element.xAxis === singleNeighbor[0] && element.yAxis === singleNeighbor[1]);
            if (neighborMatch !== undefined && neighborMatch.status === true) {
                aliveNeighbors.push(neighborMatch);
            }
        });
        if (currentItem.status === false && aliveNeighbors.length === 3) {
            newGeneration.push(currentItem)
        } else if (currentItem.status === true && (aliveNeighbors.length === 2 || aliveNeighbors.length === 3)) {
            newGeneration.push(currentItem)
        }
    });
    newGeneration.forEach(currentItem => {
        currentItem.status = true;
    });
    var display = createGridToDisplay(newGeneration)
    return { aliveCells: newGeneration, gridDisplay: display };
}
function getLowestAndHighest(arrayObj) {
    var allXAxis = [];
    var allYAxis = [];
    arrayObj.forEach(element => {
        allXAxis.push(element.xAxis);
        allYAxis.push(element.yAxis);
    });
    var lowestX = allXAxis.sort((a, b) => a - b)[0];
    var highestX = allXAxis.sort((a, b) => a - b)[allXAxis.length - 1];
    var lowestY = allYAxis.sort((a, b) => a - b)[0];
    var highestY = allYAxis.sort((a, b) => a - b)[allYAxis.length - 1];
    return { lowestX: lowestX, highestX: highestX, lowestY: lowestY, highestY: highestY }
}
function getAllNeighbors(object) {
    var allItsNeighbors = [
        [object.xAxis - 1, object.yAxis - 1],
        [object.xAxis - 1, object.yAxis + 1],
        [object.xAxis - 1, object.yAxis],
        [object.xAxis + 1, object.yAxis],
        [object.xAxis + 1, object.yAxis - 1],
        [object.xAxis + 1, object.yAxis + 1],
        [object.xAxis, object.yAxis - 1],
        [object.xAxis, object.yAxis + 1]];
    return allItsNeighbors;
}
function createGridToDisplay(aliveCells) {
    var gridToDisplay = [];
    for (let xAxisCounter = 0; xAxisCounter <= 19; xAxisCounter++) {
        for (let yAxisCounter = 0; yAxisCounter <= 19; yAxisCounter++) {
            gridToDisplay.push({ xAxis: xAxisCounter, yAxis: yAxisCounter, status: false })
        }
    }
    aliveCells.forEach(currentItem => {
        var itemFound = gridToDisplay.find(element => element.xAxis === currentItem.xAxis && element.yAxis === currentItem.yAxis);
        if (itemFound !== undefined) {
            gridToDisplay[gridToDisplay.indexOf(itemFound)].status = true;
        }
    });
    return gridToDisplay;
}
module.exports = { generateNextGeneration, getAllNeighbors, getLowestAndHighest }