function createGrid(highestVal) {
    var grid = []
    for (var x = -highestVal; x <=highestVal; x++) {
        for (var y = -highestVal; y <= highestVal; y++) {
            grid.push({ 'x': x, 'y': y, isAlive: false })
        }
    }
    return grid;
}

function setInitialGeneration(highestVal,aliveCells) {
    var grid = createGrid(highestVal);
    for (var i = 0; i < grid.length; i++) {
        for (var cell of aliveCells) {
            if (grid[i].x === cell.x && grid[i].y === cell.y) {
                grid[i] = cell;
            }
        }
    }
    return grid
}

function getNeighbours(board) {
    var interections = [];
    for (var i = 0; i < board.length; i++) {
        var p1 = board.find((cell) => cell.x === board[i].x && cell.y === board[i].y + 1)
        var p2 = board.find((cell) => cell.x === board[i].x && cell.y === board[i].y - 1);
        var p3 = board.find((cell) => cell.x === board[i].x + 1 && cell.y === board[i].y);
        var p4 = board.find((cell) => cell.x === board[i].x - 1 && cell.y === board[i].y);
        var p7 = board.find((cell) => cell.x === board[i].x - 1 && cell.y === board[i].y + 1);
        var p8 = board.find((cell) => cell.x === board[i].x + 1 && cell.y === board[i].y + 1);
        var p5 = board.find((cell) => cell.x === board[i].x - 1 && cell.y === board[i].y - 1);
        var p6 = board.find((cell) => cell.x === board[i].x + 1 && cell.y === board[i].y - 1);
        var ni = [p1, p2, p3, p4, p7, p8, p5, p6].filter((cell) => cell !== undefined);

        var newNi = ni.filter((cell) => cell.isAlive === true);

        interections.push({ cell: { 'x': board[i].x, 'y': board[i].y, isAlive: board[i].isAlive }, neighbours: newNi, len: newNi.length });

    }
    return interections;
}


function createNewGeneration(board, theGrid) {
    for (var i in board) {
        if (board[i].len === 2 && board[i].cell.isAlive === true || board[i].len === 3 && board[i].cell.isAlive === true) {
            theGrid[i].isAlive = true;
        }
        else if (board[i].len < 2 && board[i].cell.isAlive === true) {
            theGrid[i].isAlive = false;
        }
        else if (board[i].len > 3 && board[i].cell.isAlive === true) {
            theGrid[i].isAlive = false;
        }
        else if (board[i].len === 3 && board[i].cell.isAlive === false) {
            theGrid[i].isAlive = true;

        }
    }
    return theGrid
}



module.exports = { setInitialGeneration, getNeighbours, createNewGeneration,createGrid}  

import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import { setInitialGeneration, getNeighbours, createNewGeneration, createGrid } from "./game-of-life";
import { pickRandom} from "./randomPatterns";

class GameOfLife extends React.Component {
    constructor() {
        super()
        this.state = { speed: 50,gameOn: {}, grid: [], currentGen: [] , standardGridLength: 10, hiddenGridLength: 30, generationCount: 0}
    }

    componentDidMount() {
        var counter = this.state.generationCount;
        var time = this.state.speed;
        var onlyTrue = pickRandom()
        var validGrid = setInitialGeneration(this.state.standardGridLength,onlyTrue);
        this.setState({ gameOn: validGrid , currentGen:onlyTrue});
        this.setState({
            gameOn: setInterval(() => {
                this.setState({generationCount:counter++})
                this.start(this.state.currentGen)
            }, 50)
        });
    }


    start(alive) {
        var grid = setInitialGeneration(this.state.hiddenGridLength,alive);
        var neigbourHood = getNeighbours(grid);
        var changedGrid = createNewGeneration(neigbourHood, grid);
        var onlyTrue = changedGrid.filter(function (c) { return c.isAlive === true });
        var validGrid = setInitialGeneration(this.state.standardGridLength,onlyTrue);
        this.setState({ currentGen: onlyTrue, grid:validGrid })
        var generation = this.state.currentGen
        if (generation.length === 0) {
            this.setState({ gameOn: clearInterval(this.state.gameOn) });
        }
        return this.state.currentGen
    }

    play() {
        var counter = this.state.generationCount;
        var time = this.state.speed;
        this.setState({
            gameOn: setInterval(() => {
                this.setState({generationCount:counter++})
                this.start(this.state.currentGen)
            }, time),
        });
    }
   
    seedWithRandom(){
        var aliveOnly = pickRandom()
        var counter = this.state.generationCount;
       var time = this.state.speed;
       console.log('time:',this.state.speed)
        this.setState({currentGen:aliveOnly});
        this.setState({
            gameOn: setInterval(() => {
                this.setState({generationCount:counter++})
                this.start(this.state.currentGen)
            }, time)
        });
    }
    
    clearBoard() {
        this.setState({generationCount:0, currentGen: [], grid: createGrid(10), gameOn: clearInterval(this.state.gameOn) });
    }

    pause() {
        this.setState({ gameOn: clearInterval(this.state.gameOn) });
    }

    seed(id) {
        var listOfIds = this.state.currentGen;
        if(id.isAlive === false){
            id.isAlive = true;
            listOfIds.push(id);
        }
        
        this.setState({ currentGen: listOfIds})

        if(this.state.generationCount === 0){
        this.setState({generationCount:+1 })
            
        }
    }

    // increaseSpeed(){
    //     // var time = this.state.speed;      
    //     this.setState({speed:this.state.speed-100})
    //     if(this.state.speed === 100){
    //         this.setState({speed:100})  
    //     }
    // }

    // decreaseSpeed(){
    //     //var time = this.state.speed;      
    //     this.setState({speed:this.state.speed+100})
    // }

    render() {
        console.log(this.state.currentGen)
        return (

            <div>
                <center><h1 className={'text-light'}>GameOfLife</h1></center>

                <div className={'row col-md-12 container'}>
                    <button className={'btn btn-success col-md-2'} onClick={this.play.bind(this)}>Play</button>
                    <button className={'btn btn-primary col-md-2'} onClick={this.pause.bind(this)}>Pause</button>
                    <button className={'btn btn-danger col-md-2'} onClick={this.clearBoard.bind(this)}>Clear</button>
                    <button className={'btn btn-light col-md-2'} onClick={this.seedWithRandom.bind(this)}>Play Random</button>
                    <h5 className={'col-md-3'}>Generation:{this.state.generationCount}</h5>
                    {/* <button className={'down-arrow col-md-1'} onClick={this.decreaseSpeed.bind(this)}>-</button>
                    <h5 className = {'col-md-1'}>{this.state.speed}</h5>
                    <button className={'up-arrow col-md-1'} onClick={this.increaseSpeed.bind(this)}>+</button> */}
                </div>
                <div className={'container grid row col-md-12'}>
                    {this.state.grid.map((cell) => <button className={`cell ${cell.isAlive}`} onClick={() => this.seed(cell)} key={`${cell.x},${cell.y}`}></button>)}
                </div>

            </div>
        )
    }

}
// =======================================================================================================================================================================================================================================

ReactDOM.render(
    <GameOfLife />,
    document.getElementById('root')
);


var chai = require('chai');
var expect = chai.expect;
var assert = require('assert');
var gameOfLife = require('../game-of-life');

describe('test game-of-life', function () {
    it('when the grid is seeded with initial live cells, only those cells are alive and the rest are dead', function () {
        var initialAliveCells = [{ 'x': 0, 'y': 1, isAlive: true }, { 'x': 0, 'y': 2, isAlive: true }, { 'x': 0, 'y': 3, isAlive: true }];
        var initialGrid = gameOfLife.setInitialGeneration(initialAliveCells);


        for (var aliveCell of initialAliveCells) {
            var cellInGrid = initialGrid.find(c => c.x === aliveCell.x && c.y === aliveCell.y);
            expect(cellInGrid.isAlive).to.be.true;
        }

        var deadCells = initialGrid.filter(c => !c.isAlive);

        expect(deadCells.length).to.eql(initialGrid.length - initialAliveCells.length);


    })

    it('A dead cell with three live neighbours come to life in the next generation', function () {
        var initialAliveCells = [{ 'x': 0, 'y': 1, isAlive: true }, { 'x': 0, 'y': 2, isAlive: true }, { 'x': 0, 'y': 3, isAlive: true }];
        var initialGrid = gameOfLife.setInitialGeneration(initialAliveCells);
        var neighbours = gameOfLife.getNeighbours(initialGrid);
        var newAliveCells = gameOfLife.createNewGeneration(neighbours, initialGrid);
        var cellInGrid = newAliveCells.filter(function (c) { return c.isAlive === true });


        expect(cellInGrid).to.be.eql([{ 'x': -1, 'y': 2, isAlive: true }, { 'x': 0, 'y': 2, isAlive: true }, { 'x': 1, 'y': 2, isAlive: true }]);


    });
    it('a living cell that has two or three alive neighbours should stay alive in the next generation', function () {
        var initialAliveCells = [{ 'x': 0, 'y': 1, isAlive: true }, { 'x': 0, 'y': 2, isAlive: true }, { 'x': 0, 'y': 3, isAlive: true }];
        var initialGrid = gameOfLife.setInitialGeneration(initialAliveCells);
        var neighbours = gameOfLife.getNeighbours(initialGrid);
        var newAliveCells = gameOfLife.createNewGeneration(neighbours, initialGrid);
        var cellInGrid = newAliveCells.filter(function (c) { return c.isAlive === true });


        expect(cellInGrid.find((cell) => cell.x === initialAliveCells[1].x && cell.y === initialAliveCells[1].y)).to.be.eql(initialAliveCells[1]);


    });
    it('a living cell with less than two neighbours should be dead in the next generation', function () {
        var initialAliveCells = [{ 'x': 0, 'y': 1, isAlive: true }, { 'x': 0, 'y': 2, isAlive: true }, { 'x': 0, 'y': 3, isAlive: true }];
        var initialGrid = gameOfLife.setInitialGeneration(initialAliveCells);
        var neighbours = gameOfLife.getNeighbours(initialGrid);
        var newAliveCells = gameOfLife.createNewGeneration(neighbours, initialGrid);
        var cellInGrid = newAliveCells.filter(function (c) { return c.isAlive === false });
        var fromAliveToDead = [];

        for (var livingCell of initialAliveCells) {
            var val = newAliveCells.find(cell => cell.x === livingCell.x && cell.y === livingCell.y)
            fromAliveToDead.push(val);
        
        }


        expect(fromAliveToDead).to.be.eql([{ 'x': 0, 'y': 1, isAlive: false }, { 'x': 0, 'y': 2, isAlive: true }, { 'x': 0, 'y': 3, isAlive: false }]);



    });
    it('a living cell with more than three neighbours should be dead in the next generation', function () {
        var initialAliveCells = [{ 'x': 1, 'y': 1, isAlive: true }, { 'x': 1, 'y': 2, isAlive: true }, { 'x': 1, 'y': 3, isAlive: true },{ 'x': 0, 'y': 1, isAlive: true }, { 'x': 0, 'y': 2, isAlive: true }, { 'x': 0, 'y': 3, isAlive: true }];
        var initialGrid = gameOfLife.setInitialGeneration(initialAliveCells);
        var neighbours = gameOfLife.getNeighbours(initialGrid);
        var newAliveCells = gameOfLife.createNewGeneration(neighbours, initialGrid);
        var cellInGrid = newAliveCells.filter(function (c) { return c.isAlive === false });
        var fromAliveToDead = [];

        for (var livingCell of initialAliveCells) {
            var val = newAliveCells.find(cell => cell.x === livingCell.x && cell.y === livingCell.y);
            fromAliveToDead.push(val);
        
        }
        var changedState = fromAliveToDead.filter(c => c.isAlive === false);
       

    expect(changedState).to.be.eql([{ 'x': 1, 'y': 2, isAlive: false }, { 'x': 0, 'y': 2, isAlive: false }]);
    });
})

function generateNextGeneration(currentGeneration) {
    var grid = [];
    var newGeneration = [];
    if (currentGeneration === undefined) {
        currentGeneration = [];
        for (let secondIndex = 5; secondIndex < 19; secondIndex++) {
            for (let index = 5; index < 19; index++) {
                let newItem = { xAxis: Math.floor(Math.random() * 19), yAxis: Math.floor(Math.random() * 19), status: true };
                if (currentGeneration.indexOf(newItem) === -1) {
                    currentGeneration.push(newItem);
                }
            }
        }
    }
    var lowestAndHighest = getLowestAndHighest(currentGeneration)
    for (let xAxisCounter = lowestAndHighest.lowestX - 2; xAxisCounter <= lowestAndHighest.highestX + 2; xAxisCounter++) {
        for (let yAxisCounter = lowestAndHighest.lowestY - 2; yAxisCounter <= lowestAndHighest.highestY + 2; yAxisCounter++) {
            grid.push({ xAxis: xAxisCounter, yAxis: yAxisCounter, status: false })
        }
    }
    currentGeneration.forEach(currentItem => {
        var ItemFound = grid.find(item => item.xAxis === currentItem.xAxis && item.yAxis === currentItem.yAxis);
        var position = grid.indexOf(ItemFound);
        grid[position].status = true
    });
    grid.forEach(currentItem => {
        var aliveNeighbors = [];
        var currentItemsNeighbors = getAllNeighbors(currentItem);
        currentItemsNeighbors.forEach(singleNeighbor => {
            var neighborMatch = grid.find(element => element.xAxis === singleNeighbor[0] && element.yAxis === singleNeighbor[1]);
            if (neighborMatch !== undefined && neighborMatch.status === true) {
                aliveNeighbors.push(neighborMatch);
            }
        });
        if (currentItem.status === false && aliveNeighbors.length === 3) {
            newGeneration.push(currentItem)
        } else if (currentItem.status === true && (aliveNeighbors.length === 2 || aliveNeighbors.length === 3)) {
            newGeneration.push(currentItem)
        }
    });
    newGeneration.forEach(currentItem => {
        currentItem.status = true;
    });
    var display = createGridToDisplay(newGeneration)
    return { aliveCells: newGeneration, gridDisplay: display };
}
function getLowestAndHighest(arrayObj) {
    var allXAxis = [];
    var allYAxis = [];
    arrayObj.forEach(element => {
        allXAxis.push(element.xAxis);
        allYAxis.push(element.yAxis);
    });
    var lowestX = allXAxis.sort((a, b) => a - b)[0];
    var highestX = allXAxis.sort((a, b) => a - b)[allXAxis.length - 1];
    var lowestY = allYAxis.sort((a, b) => a - b)[0];
    var highestY = allYAxis.sort((a, b) => a - b)[allYAxis.length - 1];
    return { lowestX: lowestX, highestX: highestX, lowestY: lowestY, highestY: highestY }
}
function getAllNeighbors(object) {
    var allItsNeighbors = [
        [object.xAxis - 1, object.yAxis - 1],
        [object.xAxis - 1, object.yAxis + 1],
        [object.xAxis - 1, object.yAxis],
        [object.xAxis + 1, object.yAxis],
        [object.xAxis + 1, object.yAxis - 1],
        [object.xAxis + 1, object.yAxis + 1],
        [object.xAxis, object.yAxis - 1],
        [object.xAxis, object.yAxis + 1]];
    return allItsNeighbors;
}
function createGridToDisplay(aliveCells) {
    var gridToDisplay = [];
    for (let xAxisCounter = 0; xAxisCounter <= 19; xAxisCounter++) {
        for (let yAxisCounter = 0; yAxisCounter <= 19; yAxisCounter++) {
            gridToDisplay.push({ xAxis: xAxisCounter, yAxis: yAxisCounter, status: false })
        }
    }
    aliveCells.forEach(currentItem => {
        var itemFound = gridToDisplay.find(element => element.xAxis === currentItem.xAxis && element.yAxis === currentItem.yAxis);
        if (itemFound !== undefined) {
            gridToDisplay[gridToDisplay.indexOf(itemFound)].status = true;
        }
    });
    return gridToDisplay;
}
module.exports = { generateNextGeneration, getAllNeighbors, getLowestAndHighest }


